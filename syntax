program 
    ::= top-level-stmt+

top-level-stmt
    ::= import-stmt
    |   struct-def
    |   enum-def
    |   contract-def

struct-def
    ::= |struct| identifier |{| struct-member-decl+ |}|

struct-member-decl
    ::= type identifier

enum-def
    ::= |enum| identifier |{| |}|

contract-def
    ::= proxy-def
    |   facet-def
    |   contract-def

proxy-contract-def
    ::= proxy-kind |proxy| identifier |for| identifier+ |{| proxy-member-decl* |}|

proxy-member-decl
    ::= proxy-member-kind member-visibility type identifier

proxy-member-kind
    ::= @*
    |   @identifier

proxy-kind
    ::= |open|
    |   |closed|

facet-contract-def
    ::= |facet| identifier |to| identifier+ |{| facet-member-decl* |}|

facet-member-decl
    ::= visibility-kind payability-kind function-kind identifier arg-list |{| stmt* |}|

visibility-kind
    ::= |pub|
    |   |pvt|
    |   |int|
    |   |ext|

payability-kind
    ::= |$|
    |   |!|

function-kind
    ::= |fn|
    |   |proc|

arg-list
    ::= |(| (type identifier |,|)* |)| |=>| type

stmt
    ::= expression-stmt
    |   storage-assignment-stmt
    |   memory-decl-stmt
    |   memory-assignment-stmt
    |   if-stmt
    |   while-stmt
    |   revert-stmt
    |   while-stmt

expression-stmt
    ::= expression |;|

storage-assignment-stmt
    ::= identifier |<-| expression |;|

memory-decl-stmt
    ::= type identifier |=| expression |;|

memory-assignment-stmt
    ::= identifier |=| expression |;|

if-stmt
    ::= |if| |(| expression |)| |then| 

contract-def
    ::= |contract| identifier [|is| identifier+] |{| contract-member-decl* |}| 

======================

open proxy Market for Primary, Secondary {
    pub @       * uint256 test;
    pvt @ Primary string x; 
}

facet Primary to Market {
    pub $ fn doSomething (uint256 x) => uint256 {
    
    }

    int ! proc -doSomethingElse (string a, bytes b) => () {
        
    }
}

facet Secondary to Market {

}