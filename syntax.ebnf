program 
    ::= top-level-stmt+

top-level-stmt
    ::= import-stmt
    |   struct-def
    |   enum-def
    |   contract-def

import-stmt
    ::= |import| path |;|

struct-def
    ::= |struct| identifier |{| struct-member-decl+ |}|

struct-member-decl
    ::= type identifier |;|

enum-def
    ::= |enum| identifier |{| enum-member-decl+ |}|

enum-member-decl
    ::= identifier |;|

contract-def
    ::= proxy-def
    |   facet-def
    |   contract-def

proxy-def
    ::= proxy-kind |proxy| identifier |for| identifier+ |{| proxy-member-decl* |}|

proxy-member-decl
    ::= proxy-member-kind field-decl

proxy-member-kind
    ::= @*
    |   @identifier

proxy-kind
    ::= |open|
    |   |closed|

facet-def
    ::= |facet| identifier |to| identifier+ |{| facet-member-decl* |}|

facet-member-decl
    ::= function-decl

function-decl
    ::= visibility-kind payability-kind function-kind identifier arg-list block

field-decl
    ::= member-visibility [field-modifier] type identifier

field-modifier
    ::= const

block
    ::= |{| stmt* |}|

visibility-kind
    ::= |pub|
    |   |pvt|
    |   |int|
    |   |ext|

payability-kind
    ::= |$|
    |   |!|

function-kind
    ::= |fn|
    |   |proc|

arg-list
    ::= |(| (type identifier |,|)* |)| |=>| type

stmt
    ::= expression-stmt
    |   storage-assignment-stmt
    |   memory-decl-stmt
    |   memory-assignment-stmt
    |   if-stmt
    |   while-stmt
    |   require-stmt
    |   return-stmt

expression-stmt
    ::= expression |;|

storage-assignment-stmt
    ::= identifier |<-| expression |;|

memory-decl-stmt
    ::= type identifier |=| expression |;|

memory-assignment-stmt
    ::= identifier |=| expression |;|

if-stmt
    ::= |if| |(| expression |)| block |else| block

while-stmt
    ::= |while| |(| expression |)| block

require-statement
    ::= |require| |(| expression |,| expression |)| |;|

return-statement
    ::= |return| expression |;|

contract-def
    ::= |contract| identifier [|is| identifier+] |{| contract-member-decl* |}| 

expression
    ::= string-expression
    |   bytes-expression
    |   logical-expression 
    |   relational-expression
    |   arithmetic-expression  

string-expression
    ::= string-term

string-term
    ::= string-factor

string-factor
    ::= identifier
    |   string-literal
    |   |(| string-expression |)|

bytes-expression
    ::= bytes-term

bytes-term
    ::= bytes-factor

bytes-factor
    ::= identifier
    |   bytes-literal
    |   |(| bytes-expression |)|

logical-exprsesion 
    ::= logical-term |&&| logical-term
    |   logical-term |||| logical-term

logical-term
    ::= |!| |logical-factor|

logical-factor
    ::= identifier
    |   logical-literal
    |   |(| logical-expression |)|

relational-expression
    ::= relational-term |==| relational-term
    |   relational-term |!=| relational-term

relational-term
    ::= relational-factor |<| relational-factor
    |   relational-factor |>| relational-factor
    |   relational-factor |>=| relational-factor
    |   relational-factor |<=| relational-factor

relational-factor
    ::= identifier
    |   relational-literal
    |   |(| relational-expression |)|

arithmetic-expression
    ::= arithmetic-term |+| arithmetic-term
    |   arithmetic-term |-| arithmetic-term  

arithmetic-term
    ::= arithmetic-factor |*| arithmetic-factor
    |   arithmetic-factor |/| arithmetic-factor

arithmetic-factor
    ::= identifier
    |   arithmetic-literal
    |   |(| arithmetic-expression |)|

type
    ::= |uint| uint-size
    |   |string|
    |   |bool|
    |   |bytes| bytes-size
    |   |bytes|
    |   |address|

uint-size
    ::= 8 | 16 | ... | 256

bytes-size
    ::= 1 | 2 | ... | 32

======================

open proxy Market for Primary, Secondary {
    @       * pub  uint256 test;
    @ Primary pvt  string x; 
}

facet Primary to Market {
    pub $ fn doSomething (uint256 x) => uint256 {
    
    }

    int ! proc -doSomethingElse (string a, bytes b) => () {
        
    }
}

facet Secondary to Market {

}